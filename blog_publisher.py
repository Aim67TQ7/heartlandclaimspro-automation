#!/usr/bin/env python3
"""
Blog Publishing Workflow

This script handles the workflow for publishing blog posts generated by the
BlogContentGenerator. It prepares the content for publishing on a website
and provides tools for manual publishing.
"""

import os
import json
import argparse
import shutil
from datetime import datetime
import re
import sys

# Add the current directory to the path to import BlogContentGenerator
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from blog_generator import BlogContentGenerator

class BlogPublisher:
    """
    A class to handle the publishing workflow for blog posts.
    """
    
    def __init__(self, data_dir="/home/ubuntu/blog_automation"):
        """
        Initialize the BlogPublisher.
        
        Args:
            data_dir (str): Directory containing blog data files
        """
        self.data_dir = data_dir
        self.content_dir = os.path.join(data_dir, "generated_content")
        self.publish_dir = os.path.join(data_dir, "ready_to_publish")
        self.published_dir = os.path.join(data_dir, "published")
        self.images_dir = os.path.join(data_dir, "images")
        
        # Create directories if they don't exist
        for directory in [self.content_dir, self.publish_dir, self.published_dir, self.images_dir]:
            os.makedirs(directory, exist_ok=True)
        
        # Initialize the content generator
        self.generator = BlogContentGenerator(data_dir=data_dir)
        
        print(f"BlogPublisher initialized with data from {data_dir}")
    
    def prepare_for_publishing(self, blog_file, edit=False):
        """
        Prepare a blog post for publishing.
        
        Args:
            blog_file (str): Path to the blog post JSON file
            edit (bool): Whether to open the file for editing
        
        Returns:
            str: Path to the prepared Markdown file
        """
        # Load the blog post
        try:
            with open(blog_file, 'r') as f:
                blog_post = json.load(f)
        except Exception as e:
            print(f"Error loading blog post: {e}")
            return None
        
        # Generate Markdown
        markdown_content = self.generator.generate_markdown(blog_post)
        
        # Create a filename based on the title
        title_slug = blog_post["title"].lower().replace(" ", "-")
        title_slug = re.sub(r'[^a-z0-9-]', '', title_slug)
        filename = f"{title_slug}.md"
        filepath = os.path.join(self.publish_dir, filename)
        
        # Save the Markdown file
        try:
            with open(filepath, 'w') as f:
                f.write(markdown_content)
            print(f"Prepared blog post for publishing: {filepath}")
            
            # Open for editing if requested
            if edit:
                self._open_for_editing(filepath)
            
            return filepath
        except Exception as e:
            print(f"Error preparing blog post: {e}")
            return None
    
    def _open_for_editing(self, filepath):
        """
        Open a file for editing.
        
        Args:
            filepath (str): Path to the file to edit
        """
        try:
            # Try to use the default editor
            editor = os.environ.get('EDITOR', 'nano')
            os.system(f"{editor} {filepath}")
        except Exception as e:
            print(f"Error opening file for editing: {e}")
    
    def mark_as_published(self, blog_file):
        """
        Mark a blog post as published.
        
        Args:
            blog_file (str): Path to the blog post file
        
        Returns:
            bool: Success status
        """
        # Check if file exists
        if not os.path.exists(blog_file):
            print(f"File not found: {blog_file}")
            return False
        
        # Get the filename
        filename = os.path.basename(blog_file)
        
        # Create destination path
        destination = os.path.join(self.published_dir, filename)
        
        # Move the file
        try:
            shutil.move(blog_file, destination)
            print(f"Marked as published: {destination}")
            return True
        except Exception as e:
            print(f"Error marking as published: {e}")
            return False
    
    def generate_and_prepare(self, topic=None, template_type=None, storm_type=None):
        """
        Generate a new blog post and prepare it for publishing.
        
        Args:
            topic (str): Specific topic for the blog post
            template_type (str): Type of template to use
            storm_type (str): Specific storm type to focus on
        
        Returns:
            str: Path to the prepared Markdown file
        """
        # Generate a new blog post
        blog_post = self.generator.generate_blog_post(
            topic=topic,
            template_type=template_type,
            storm_type=storm_type
        )
        
        # Generate Markdown
        markdown_content = self.generator.generate_markdown(blog_post)
        
        # Create a filename based on the title
        title_slug = blog_post["title"].lower().replace(" ", "-")
        title_slug = re.sub(r'[^a-z0-9-]', '', title_slug)
        filename = f"{title_slug}.md"
        filepath = os.path.join(self.publish_dir, filename)
        
        # Save the Markdown file
        try:
            with open(filepath, 'w') as f:
                f.write(markdown_content)
            print(f"Generated and prepared blog post for publishing: {filepath}")
            return filepath
        except Exception as e:
            print(f"Error preparing blog post: {e}")
            return None
    
    def prepare_weekly_post(self, week_number=None):
        """
        Prepare a blog post based on the weekly plan.
        
        Args:
            week_number (int): Week number from the plan
        
        Returns:
            str: Path to the prepared Markdown file
        """
        # Load the weekly plan
        plan_file = os.path.join(self.data_dir, "weekly_blog_plan.md")
        if not os.path.exists(plan_file):
            print(f"Weekly plan not found: {plan_file}")
            print("Generating a new weekly plan...")
            plan_file = self.generator.save_weekly_plan()
            if not plan_file:
                return None
        
        # Read the plan file
        try:
            with open(plan_file, 'r') as f:
                plan_content = f.read()
        except Exception as e:
            print(f"Error reading weekly plan: {e}")
            return None
        
        # Determine which week to use
        if week_number is None:
            # Find the first week that doesn't have a corresponding published file
            for week in range(1, 53):
                week_match = re.search(f'## Week {week}\n\n(.*?)(?=\n\n##|\Z)', plan_content, re.DOTALL)
                if not week_match:
                    continue
                
                week_content = week_match.group(1)
                title_match = re.search(r'\*\*Title:\*\* (.*?)\n', week_content)
                if not title_match:
                    continue
                
                title = title_match.group(1)
                title_slug = title.lower().replace(" ", "-")
                title_slug = re.sub(r'[^a-z0-9-]', '', title_slug)
                
                published_file = os.path.join(self.published_dir, f"{title_slug}.md")
                if not os.path.exists(published_file):
                    week_number = week
                    break
            
            if week_number is None:
                print("All weeks in the plan have been published.")
                return None
        
        # Extract information for the specified week
        week_match = re.search(f'## Week {week_number}\n\n(.*?)(?=\n\n##|\Z)', plan_content, re.DOTALL)
        if not week_match:
            print(f"Week {week_number} not found in the plan.")
            return None
        
        week_content = week_match.group(1)
        
        # Extract title, topic, template type, and storm type
        title_match = re.search(r'\*\*Title:\*\* (.*?)\n', week_content)
        topic_match = re.search(r'\*\*Topic:\*\* (.*?)\n', week_content)
        template_match = re.search(r'\*\*Template Type:\*\* (.*?)\n', week_content)
        storm_match = re.search(r'\*\*Storm Type Focus:\*\* (.*?)\n', week_content)
        
        if not all([title_match, topic_match, template_match, storm_match]):
            print(f"Incomplete information for week {week_number}.")
            return None
        
        topic = topic_match.group(1)
        template_type = template_match.group(1)
        storm_type = storm_match.group(1)
        
        print(f"Preparing blog post for Week {week_number}:")
        print(f"Topic: {topic}")
        print(f"Template Type: {template_type}")
        print(f"Storm Type: {storm_type}")
        
        # Generate and prepare the blog post
        return self.generate_and_prepare(
            topic=topic,
            template_type=template_type,
            storm_type=storm_type
        )
    
    def suggest_images(self, blog_file):
        """
        Suggest images for a blog post.
        
        Args:
            blog_file (str): Path to the blog post file
        
        Returns:
            dict: Dictionary of image suggestions
        """
        # Load the blog post
        try:
            if blog_file.endswith('.json'):
                with open(blog_file, 'r') as f:
                    blog_post = json.load(f)
                    
                    if 'suggested_images' in blog_post:
                        return blog_post['suggested_images']
            
            elif blog_file.endswith('.md'):
                with open(blog_file, 'r') as f:
                    content = f.read()
                
                # Extract image suggestions from comments
                image_section = re.search(r'<!-- Image Suggestions:\n(.*?)-->', content, re.DOTALL)
                if image_section:
                    image_text = image_section.group(1)
                    
                    header_match = re.search(r'Header Image: (.*?)\n', image_text)
                    header_image = header_match.group(1) if header_match else "Storm damage to property"
                    
                    section_images = []
                    section_matches = re.findall(r'- (.*?)\n', image_text)
                    if section_matches:
                        section_images = section_matches
                    
                    resource_match = re.search(r'Resource Preview: (.*?)\n', image_text)
                    resource_preview = resource_match.group(1) if resource_match else "Downloadable resource preview"
                    
                    return {
                        "header_image": header_image,
                        "section_images": section_images,
                        "resource_preview": resource_preview
                    }
        
        except Exception as e:
            print(f"Error loading blog post for image suggestions: {e}")
        
        # Default suggestions if loading fails
        return {
            "header_image": "Storm damage to residential property",
            "section_images": [
                "Person reviewing insurance documents",
                "Storm damage documentation process",
                "Insurance adjuster inspecting property",
                "Homeowner speaking with insurance representative",
                "Successful claim resolution"
            ],
            "resource_preview": "Preview of downloadable resource"
        }
    
    def create_image_placeholders(self, blog_file):
        """
        Create placeholder images for a blog post.
        
        Args:
            blog_file (str): Path to the blog post file
        
        Returns:
            list: Paths to created placeholder images
        """
        # Get image suggestions
        suggestions = self.suggest_images(blog_file)
        
        # Create a directory for this blog's images
        blog_name = os.path.basename(blog_file).replace('.md', '').replace('.json', '')
        blog_images_dir = os.path.join(self.images_dir, blog_name)
        os.makedirs(blog_images_dir, exist_ok=True)
        
        created_files = []
        
        # Create a text file for each suggested image
        # In a real implementation, this would generate or download actual images
        
        # Header image
        header_file = os.path.join(blog_images_dir, "header.txt")
        with open(header_file, 'w') as f:
            f.write(f"Header Image Suggestion: {suggestions['header_image']}\n")
            f.write("In a real implementation, this would be an actual image file.\n")
            f.write("For now, use this as a placeholder and replace with a real image before publishing.\n")
        created_files.append(header_file)
        
        # Section images
        for i, suggestion in enumerate(suggestions.get('section_images', [])):
            section_file = os.path.join(blog_images_dir, f"section_{i+1}.txt")
            with open(section_file, 'w') as f:
                f.write(f"Section Image Suggestion: {suggestion}\n")
                f.write("In a real implementation, this would be an actual image file.\n")
                f.write("For now, use this as a placeholder and replace with a real image before publishing.\n")
            created_files.append(section_file)
        
        # Resource preview
        resource_file = os.path.join(blog_images_dir, "resource.txt")
        with open(resource_file, 'w') as f:
            f.write(f"Resource Preview Suggestion: {suggestions.get('resource_preview', 'Downloadable resource preview')}\n")
            f.write("In a real implementation, this would be an actual image file.\n")
            f.write("For now, use this as a placeholder and replace with a real image before publishing.\n")
        created_files.append(resource_file)
        
        print(f"Created {len(created_files)} image placeholders in {blog_images_dir}")
        return created_files
    
    def list_ready_posts(self):
        """
        List all blog posts ready for publishing.
        
        Returns:
            list: List of blog post files
        """
        ready_posts = []
        
        # Check if directory exists
        if not os.path.exists(self.publish_dir):
            print(f"Publish directory not found: {self.publish_dir}")
            return ready_posts
        
        # List all Markdown files
        for filename in os.listdir(self.publish_dir):
            if filename.endswith('.md'):
                ready_posts.append(os.path.join(self.publish_dir, filename))
        
        return ready_posts
    
    def list_published_posts(self):
        """
        List all published blog posts.
        
        Returns:
            list: List of published blog post files
        """
        published_posts = []
        
        # Check if directory exists
        if not os.path.exists(self.published_dir):
            print(f"Published directory not found: {self.published_dir}")
            return published_posts
        
        # List all Markdown files
        for filename in os.listdir(self.published_dir):
            if filename.endswith('.md'):
                published_posts.append(os.path.join(self.published_dir, filename))
        
        return published_posts
    
    def create_html_version(self, markdown_file):
        """
        Create an HTML version of a Markdown blog post.
        
        Args:
            markdown_file (str): Path to the Markdown file
        
        Returns:
            str: Path to the HTML file
        """
        try:
            # Check if markdown file exists
            if not os.path.exists(markdown_file):
                print(f"Markdo
(Content truncated due to size limit. Use line ranges to read in chunks)